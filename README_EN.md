# Music Player

A cross-platform desktop music player built with Tauri 2.

> **Note**: Most of the code in this project was generated by [Gemini CLI](https://github.com/google/generative-ai-docs) and [Claude Code](https://github.com/anthropics/claude-code), with a few bugs fixed manually.

## ğŸš§ Project Status

This project is currently under development and may contain some bugs and incomplete features. Issues and Pull Requests are welcome at [Issues](../../issues) and [Pull Requests](../../pulls)!

## âœ¨ Features

- ğŸµ Local music file playback
- ğŸ“ Folder scanning and management
- ğŸ¨ Modern user interface
- ğŸ’¾ SQLite database for music library storage
- ğŸ–¼ï¸ Album artwork display
- ğŸ“‹ Playlist management (TODO)

## ğŸ› ï¸ Tech Stack

### Frontend
- **React 19** - UI framework
- **TypeScript** - Type safety
- **Vite** - Build tool
- **Tailwind CSS 4** - Styling framework
- **Zustand** - State management
- **Lucide React** - Icon library
- **Jest + Testing Library** - Unit testing

### Backend (Rust)

This project uses Rust to build high-performance backend services, with the following key technologies:

#### Core Framework
- **[Tauri 2](https://tauri.app/)** - Cross-platform desktop application framework providing lightweight WebView container and native system API access

#### Audio Processing
- **[rodio](https://github.com/RustAudio/rodio)** (v0.21.1) - Audio playback engine
  - Uses `symphonia-all` feature to support multiple audio formats (MP3, FLAC, WAV, OGG, etc.)
  - Provides audio playback controls (play, pause, volume adjustment, etc.)
- **[lofty](https://github.com/Serial-ATA/lofty-rs)** (v0.22.4) - Audio metadata reading
  - Parses audio file tag information (title, artist, album, etc.)
  - Extracts album artwork

#### Data Storage
- **[rusqlite](https://github.com/rusqlite/rusqlite)** (v0.38.0) - SQLite database bindings
  - Stores music library information, playlists, and other data
  - Provides efficient local data persistence

#### Async Runtime
- **[tokio](https://tokio.rs/)** (v1.49.0) - Asynchronous runtime
  - Uses `full` feature set for complete async I/O operations
  - Handles async tasks like file scanning and database operations

#### Utility Libraries
- **[walkdir](https://github.com/BurntSushi/walkdir)** (v2) - Recursive directory traversal
  - Scans audio files in local folders
- **[uuid](https://github.com/uuid-rs/uuid)** (v1.20.0) - UUID generation
  - Generates unique identifiers for music tracks, playlists, and other entities
- **[sha2](https://github.com/RustCrypto/hashes)** (v0.10.9) + **[hex](https://github.com/KokaKiwi/rust-hex)** (v0.4.3) - Hash computation
  - Generates file fingerprints for deduplication and caching
- **[image](https://github.com/image-rs/image)** (v0.25.9) - Image processing
  - Handles reading and conversion of album artwork
- **[serde](https://serde.rs/)** + **[serde_json](https://github.com/serde-rs/json)** - Serialization/Deserialization
  - JSON serialization for frontend-backend data exchange

#### Tauri Plugins
- **tauri-plugin-fs** - File system access
- **tauri-plugin-dialog** - Native dialogs (file picker, etc.)
- **tauri-plugin-opener** - Open external links and files

## ğŸš€ Development

### Prerequisites

- Node.js 18+
- Rust 1.70+
- pnpm (recommended) or npm

### Install Dependencies

```bash
pnpm install
```

### Development Mode

```bash
pnpm tauri dev
```

### Build

```bash
pnpm tauri build
```

### Run Tests

```bash
pnpm test
```

### Code Formatting

```bash
pnpm format
```

## ğŸ“ Development Tools

### Recommended IDE Setup

- [VS Code](https://code.visualstudio.com/)
- [Tauri Extension](https://marketplace.visualstudio.com/items?itemName=tauri-apps.tauri-vscode)
- [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer)

### Git Hooks

The project uses Husky and lint-staged for code quality control:
- Automatically format code before commits
- Run ESLint checks
- Format Rust code

## ğŸ¤ Contributing

Contributions are welcome! Please follow these steps:

1. Fork this repository
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## ğŸ“„ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
